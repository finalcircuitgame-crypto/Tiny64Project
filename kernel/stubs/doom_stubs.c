// Doom stubs for Tiny64 kernel
// Provides minimal implementations of standard library functions

#include <stdlib.h>
#include <string.h>
#include "../include/kernel.h"
#include "../hal/serial.h"

// Timer function from system_stubs.c
extern uint64_t timer_ms(void);

// Define EOF since we can't include stdio.h
#define EOF (-1)

// Embedded WAD data functions (generated by build script)
// These functions are defined in embedded_wad.c if WAD file exists
// Note: Not using weak linkage to ensure they're always linked
extern const uint8_t* get_doom1_wad_data(size_t* size);
extern const uint8_t* get_doom_wad_data(size_t* size);
extern const uint8_t* get_doom2_wad_data(size_t* size);

// FILE structure for embedded files
typedef struct {
    const uint8_t* data;      // Pointer to embedded data
    size_t size;              // Size of data
    size_t position;          // Current read position
    int valid;                // Whether file is open
} embedded_file_t;

// Stub FILE structure (we'll use embedded_file_t internally)
typedef struct {
    embedded_file_t internal;
} FILE;

// Find embedded WAD file
static const uint8_t* find_wad_data(const char* filename, size_t* size) {
    *size = 0;

    if (strcmp(filename, "doom1.wad") == 0) {
        return get_doom1_wad_data(size);
    } else if (strcmp(filename, "doom.wad") == 0) {
        return get_doom_wad_data(size);
    } else if (strcmp(filename, "doom2.wad") == 0) {
        return get_doom2_wad_data(size);
    }

    return NULL;
}

FILE* fopen(const char* filename, const char* mode) {
    // Only support read mode for now
    if (strcmp(mode, "rb") != 0 && strcmp(mode, "r") != 0) {
        return NULL;
    }

    FILE* file = (FILE*)malloc(sizeof(FILE));
    if (!file) return NULL;

    memset(file, 0, sizeof(FILE));

    size_t size;
    const uint8_t* data = find_wad_data(filename, &size);

    if (data && size > 0) {
        file->internal.data = data;
        file->internal.size = size;
        file->internal.position = 0;
        file->internal.valid = 1;
        return file;
    }

    // Not found or invalid
    free(file);
    return NULL;
}

int fclose(FILE* stream) {
    if (!stream || !stream->internal.valid) return -1;

    free(stream);
    return 0;
}

size_t fread(void* ptr, size_t size, size_t count, FILE* stream) {
    if (!stream || !stream->internal.valid || !ptr) return 0;

    size_t total_bytes = size * count;
    size_t remaining = stream->internal.size - stream->internal.position;

    if (total_bytes > remaining) {
        total_bytes = remaining;
        count = total_bytes / size;
    }

    if (total_bytes > 0) {
        memcpy(ptr, stream->internal.data + stream->internal.position, total_bytes);
        stream->internal.position += total_bytes;
    }

    return count;
}

size_t fwrite(const void* ptr, size_t size, size_t count, FILE* stream) {
    // Read-only filesystem
    return 0;
}

int fseek(FILE* stream, long offset, int origin) {
    if (!stream || !stream->internal.valid) return -1;

    size_t new_pos;

    switch (origin) {
        case 0: // SEEK_SET
            new_pos = offset;
            break;
        case 1: // SEEK_CUR
            new_pos = stream->internal.position + offset;
            break;
        case 2: // SEEK_END
            new_pos = stream->internal.size + offset;
            break;
        default:
            return -1;
    }

    if (new_pos > stream->internal.size) {
        return -1;
    }

    stream->internal.position = new_pos;
    return 0;
}

long ftell(FILE* stream) {
    if (!stream || !stream->internal.valid) return -1;

    return (long)stream->internal.position;
}

int feof(FILE* stream) {
    if (!stream || !stream->internal.valid) return 1;

    return stream->internal.position >= stream->internal.size;
}

int ferror(FILE* stream) {
    return 0; // No error tracking
}

int fflush(FILE* stream) {
    return 0; // No-op for read-only files
}

FILE* freopen(const char* filename, const char* mode, FILE* stream) {
    // Not implemented
    return NULL;
}

int remove(const char* filename) {
    // Read-only filesystem
    return -1;
}

int rename(const char* oldname, const char* newname) {
    // Read-only filesystem
    return -1;
}

// Memory allocation stubs
void* malloc(size_t size) {
    return kmalloc(size);
}

void free(void* ptr) {
    kfree(ptr);
}

void* realloc(void* ptr, size_t size) {
    // Simple realloc implementation
    if (!ptr) return kmalloc(size);
    if (!size) {
        kfree(ptr);
        return NULL;
    }

    void* new_ptr = kmalloc(size);
    if (new_ptr) {
        // Copy old data (assuming we know the old size somehow)
        // This is a simplified version
        memcpy(new_ptr, ptr, size); // This might not be safe
        kfree(ptr);
    }
    return new_ptr;
}

// Stub printf functions
int printf(const char* format) {
    // TODO: Implement printf to serial output
    serial_write_string("printf: ");
    serial_write_string(format);
    serial_write_string("\n");
    return 0;
}

int fprintf(FILE* stream, const char* format) {
    // TODO: Implement fprintf
    return printf(format);
}

int sprintf(char* str, const char* format, ...) {
    // TODO: Implement sprintf
    strcpy(str, format); // Very basic implementation
    return strlen(str);
}

int snprintf(char* str, size_t size, const char* format, ...) {
    // TODO: Implement snprintf
    if (size > 0) {
        strncpy(str, format, size - 1);
        str[size - 1] = '\0';
    }
    return strlen(str);
}

// Time functions
/* time() is provided by system_stubs.c to avoid duplicate definition */

// Stub for getchar - not used in Doom
int getchar(void) {
    return EOF;
}

// Stub for putchar
int putchar(int c) {
    char buf[2] = {c, 0};
    serial_write_string(buf);
    return c;
}

// Stub for puts
int puts(const char* s) {
    serial_write_string(s);
    serial_write_string("\n");
    return 0;
}

// Stub for atoi
int atoi(const char* str) {
    int result = 0;
    int sign = 1;

    if (*str == '-') {
        sign = -1;
        str++;
    }

    while (*str >= '0' && *str <= '9') {
        result = result * 10 + (*str - '0');
        str++;
    }

    return result * sign;
}

// Stub for exit - infinite loop to avoid crashes
void exit(int status) {
    // In kernel, we can't really exit, so loop forever
    while (1) {
        // Infinite loop
    }
}

// Stub for abort - infinite loop
void abort(void) {
    // Infinite loop
    while (1) {
        // Infinite loop
    }
}
