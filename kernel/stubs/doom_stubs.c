// Doom stubs for Tiny64 kernel
// Provides minimal implementations of standard library functions

#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include "../include/kernel.h"
#include "../hal/serial.h"

// Timer function from system_stubs.c
extern uint64_t timer_ms(void);

// Define EOF since we can't include stdio.h
#define EOF (-1)

// Embedded WAD data symbols (generated by objcopy)
// objcopy creates symbols with the pattern: _binary_<filename_without_path>_start, _end, _size
// Use weak symbols so linking doesn't fail if WAD isn't embedded
__attribute__((weak)) extern const uint8_t _binary_doom_wad_start[];
__attribute__((weak)) extern const uint8_t _binary_doom_wad_end[];
__attribute__((weak)) extern const size_t _binary_doom_wad_size;

// Stub implementations for other WAD files (not embedded)
extern const uint8_t* get_doom1_wad_data(size_t* size);
extern const uint8_t* get_doom2_wad_data(size_t* size);

// Stub implementations for non-embedded WAD files
const uint8_t* get_doom1_wad_data(size_t* size) {
    *size = 0;
    return NULL;
}

const uint8_t* get_doom2_wad_data(size_t* size) {
    *size = 0;
    return NULL;
}

// Forward declaration for vsnprintf
extern int vsnprintf(char *str, size_t size, const char *fmt, va_list ap);

// FILE structure for embedded files
typedef struct {
    const uint8_t* data;      // Pointer to embedded data
    size_t size;              // Size of data
    size_t position;          // Current read position
    int valid;                // Whether file is open
} embedded_file_t;

// Stub FILE structure (we'll use embedded_file_t internally)
typedef struct {
    embedded_file_t internal;
} FILE;

// Find embedded WAD file
static const uint8_t* find_wad_data(const char* filename, size_t* size) {
    *size = 0;

    if (strcmp(filename, "doom.wad") == 0) {
        // Check if weak symbols are available (WAD was embedded)
        if (&_binary_doom_wad_start != NULL && &_binary_doom_wad_size != NULL) {
            *size = _binary_doom_wad_size;
            return _binary_doom_wad_start;
        } else {
            // WAD not embedded, return NULL
            return NULL;
        }
    } else if (strcmp(filename, "doom1.wad") == 0) {
        return get_doom1_wad_data(size);
    } else if (strcmp(filename, "doom2.wad") == 0) {
        return get_doom2_wad_data(size);
    }

    return NULL;
}

FILE* fopen(const char* filename, const char* mode) {
    // Only support read mode for now
    if (strcmp(mode, "rb") != 0 && strcmp(mode, "r") != 0) {
        return NULL;
    }

    FILE* file = (FILE*)malloc(sizeof(FILE));
    if (!file) return NULL;

    memset(file, 0, sizeof(FILE));

    size_t size;
    const uint8_t* data = find_wad_data(filename, &size);

    if (data && size > 0) {
        file->internal.data = data;
        file->internal.size = size;
        file->internal.position = 0;
        file->internal.valid = 1;
        return file;
    }

    // Not found or invalid
    free(file);
    return NULL;
}

int fclose(FILE* stream) {
    if (!stream || !stream->internal.valid) return -1;

    free(stream);
    return 0;
}

size_t fread(void* ptr, size_t size, size_t count, FILE* stream) {
    if (!stream || !stream->internal.valid || !ptr) return 0;

    size_t total_bytes = size * count;
    size_t remaining = stream->internal.size - stream->internal.position;

    if (total_bytes > remaining) {
        total_bytes = remaining;
        count = total_bytes / size;
    }

    if (total_bytes > 0) {
        memcpy(ptr, stream->internal.data + stream->internal.position, total_bytes);
        stream->internal.position += total_bytes;
    }

    return count;
}

size_t fwrite(const void* ptr, size_t size, size_t count, FILE* stream) {
    // Read-only filesystem
    return 0;
}

int fseek(FILE* stream, long offset, int origin) {
    if (!stream || !stream->internal.valid) return -1;

    size_t new_pos;

    switch (origin) {
        case 0: // SEEK_SET
            new_pos = offset;
            break;
        case 1: // SEEK_CUR
            new_pos = stream->internal.position + offset;
            break;
        case 2: // SEEK_END
            new_pos = stream->internal.size + offset;
            break;
        default:
            return -1;
    }

    if (new_pos > stream->internal.size) {
        return -1;
    }

    stream->internal.position = new_pos;
    return 0;
}

long ftell(FILE* stream) {
    if (!stream || !stream->internal.valid) return -1;

    return (long)stream->internal.position;
}

int feof(FILE* stream) {
    if (!stream || !stream->internal.valid) return 1;

    return stream->internal.position >= stream->internal.size;
}

int ferror(FILE* stream) {
    return 0; // No error tracking
}

int fflush(FILE* stream) {
    return 0; // No-op for read-only files
}

FILE* freopen(const char* filename, const char* mode, FILE* stream) {
    // Not implemented
    return NULL;
}

int remove(const char* filename) {
    // Read-only filesystem
    return -1;
}

int rename(const char* oldname, const char* newname) {
    // Read-only filesystem
    return -1;
}

// Memory allocation stubs
void* malloc(size_t size) {
    return kmalloc(size);
}

void free(void* ptr) {
    kfree(ptr);
}

void* realloc(void* ptr, size_t size) {
    // Simple realloc implementation
    if (!ptr) return kmalloc(size);
    if (!size) {
        kfree(ptr);
        return NULL;
    }

    void* new_ptr = kmalloc(size);
    if (new_ptr) {
        // Copy old data (assuming we know the old size somehow)
        // This is a simplified version
        memcpy(new_ptr, ptr, size); // This might not be safe
        kfree(ptr);
    }
    return new_ptr;
}

// Helper function to convert integer to string
static void int_to_str(int value, char* buffer, int base) {
    char* ptr = buffer;
    int negative = 0;

    if (value < 0) {
        negative = 1;
        value = -value;
    }

    // Handle 0 case
    if (value == 0) {
        *ptr++ = '0';
        *ptr = '\0';
        return;
    }

    // Convert to string (reversed)
    char temp[32];
    int i = 0;
    while (value > 0) {
        int digit = value % base;
        temp[i++] = (digit < 10) ? ('0' + digit) : ('a' + digit - 10);
        value /= base;
    }

    // Add negative sign if needed
    if (negative) {
        *ptr++ = '-';
    }

    // Reverse and copy
    while (i > 0) {
        *ptr++ = temp[--i];
    }
    *ptr = '\0';
}

// Helper function to convert unsigned integer to string
static void uint_to_str(unsigned int value, char* buffer, int base) {
    char* ptr = buffer;

    // Handle 0 case
    if (value == 0) {
        *ptr++ = '0';
        *ptr = '\0';
        return;
    }

    // Convert to string (reversed)
    char temp[32];
    int i = 0;
    while (value > 0) {
        unsigned int digit = value % base;
        temp[i++] = (digit < 10) ? ('0' + digit) : ('a' + digit - 10);
        value /= base;
    }

    // Reverse and copy
    while (i > 0) {
        *ptr++ = temp[--i];
    }
    *ptr = '\0';
}

// Stub printf functions - basic implementation with %s, %d, %i, %u, %x support
int printf(const char* format, ...) {
    va_list args;
    va_start(args, format);

    serial_write_string("printf: ");

    // Basic printf implementation - handles %s, %d, %i, %u, %x
    const char* p = format;
    while (*p) {
        if (*p == '%' && *(p + 1) == 's') {
            // %s format specifier
            char* str = va_arg(args, char*);
            if (str) {
                serial_write_string(str);
            }
            p += 2;
        } else if (*p == '%' && (*(p + 1) == 'd' || *(p + 1) == 'i')) {
            // %d or %i format specifier
            int value = va_arg(args, int);
            char buffer[32];
            int_to_str(value, buffer, 10);
            serial_write_string(buffer);
            p += 2;
        } else if (*p == '%' && *(p + 1) == 'u') {
            // %u format specifier
            unsigned int value = va_arg(args, unsigned int);
            char buffer[32];
            uint_to_str(value, buffer, 10);
            serial_write_string(buffer);
            p += 2;
        } else if (*p == '%' && *(p + 1) == 'x') {
            // %x format specifier
            unsigned int value = va_arg(args, unsigned int);
            char buffer[32];
            uint_to_str(value, buffer, 16);
            serial_write_string(buffer);
            p += 2;
        } else if (*p == '%' && *(p + 1) == '\n') {
            // Handle %\n as just newline
            serial_write_string("\n");
            p += 2;
        } else if (*p == '\n') {
            serial_write_string("\n");
            p++;
        } else if (*p != '%') {
            // Regular character - print it
            char buf[2] = {*p, 0};
            serial_write_string(buf);
            p++;
        } else {
            // Unknown format specifier - skip it
            p++;
        }
    }

    va_end(args);
    return 0;
}

int fprintf(FILE* stream, const char* format, ...) {
    // For now, ignore stream and handle like printf
    va_list args;
    va_start(args, format);

    serial_write_string("fprintf: ");

    // Handle empty format string
    if (format == NULL) {
        serial_write_string("(null)\n");
        va_end(args);
        return 0;
    }

    if (*format == '\0') {
        serial_write_string("(empty)\n");
        va_end(args);
        return 0;
    }

    // Debug: print the format string
    serial_write_string("[");
    serial_write_string(format);
    serial_write_string("]");

    // Same basic printf implementation - handles %s, %d, %i, %u, %x, %p, %c, %f
    const char* p = format;
    while (*p) {
        if (*p == '%' && *(p + 1) == 's') {
            char* str = va_arg(args, char*);
            if (str) serial_write_string(str);
            p += 2;
        } else if (*p == '%' && (*(p + 1) == 'd' || *(p + 1) == 'i')) {
            int value = va_arg(args, int);
            char buffer[32];
            int_to_str(value, buffer, 10);
            serial_write_string(buffer);
            p += 2;
        } else if (*p == '%' && *(p + 1) == 'u') {
            unsigned int value = va_arg(args, unsigned int);
            char buffer[32];
            uint_to_str(value, buffer, 10);
            serial_write_string(buffer);
            p += 2;
        } else if (*p == '%' && *(p + 1) == 'x') {
            unsigned int value = va_arg(args, unsigned int);
            char buffer[32];
            uint_to_str(value, buffer, 16);
            serial_write_string(buffer);
            p += 2;
        } else if (*p == '%' && *(p + 1) == 'p') {
            // %p format specifier (pointer)
            void* ptr = va_arg(args, void*);
            char buffer[32];
            if (ptr == NULL) {
                serial_write_string("(nil)");
            } else {
                uint_to_str((unsigned int)(uintptr_t)ptr, buffer, 16);
                serial_write_string("0x");
                serial_write_string(buffer);
            }
            p += 2;
        } else if (*p == '%' && *(p + 1) == 'c') {
            // %c format specifier (character)
            int value = va_arg(args, int);
            char buf[2] = {value, 0};
            serial_write_string(buf);
            p += 2;
        } else if (*p == '%' && *(p + 1) == 'f') {
            // %f format specifier (float) - simplified
            double value = va_arg(args, double);
            int int_part = (int)value;
            char buffer[32];
            int_to_str(int_part, buffer, 10);
            serial_write_string(buffer);
            serial_write_string(".0"); // Just append .0 for simplicity
            p += 2;
        } else if (*p == '\n') {
            serial_write_string("\n");
            p++;
        } else if (*p != '%') {
            char buf[2] = {*p, 0};
            serial_write_string(buf);
            p++;
        } else {
            // Unknown format specifier - skip it
            p++;
        }
    }

    serial_write_string("\n");
    va_end(args);
    return 0;
}

int sprintf(char* str, const char* format, ...) {
    // TODO: Implement sprintf
    strcpy(str, format); // Very basic implementation
    return strlen(str);
}

int snprintf(char* str, size_t size, const char* format, ...) {
    va_list args;
    int result;
    
    if (size == 0) return 0;
    
    va_start(args, format);
    result = vsnprintf(str, size, format, args);
    va_end(args);
    
    return result;
}

// Time functions
/* time() is provided by system_stubs.c to avoid duplicate definition */

// Stub for getchar - not used in Doom
int getchar(void) {
    return EOF;
}

// Stub for putchar
int putchar(int c) {
    char buf[2] = {c, 0};
    serial_write_string(buf);
    return c;
}

// Stub for puts
int puts(const char* s) {
    serial_write_string(s);
    serial_write_string("\n");
    return 0;
}

// Stub for atoi
int atoi(const char* str) {
    int result = 0;
    int sign = 1;

    if (*str == '-') {
        sign = -1;
        str++;
    }

    while (*str >= '0' && *str <= '9') {
        result = result * 10 + (*str - '0');
        str++;
    }

    return result * sign;
}

// Stub for exit - just return to caller
void exit(int status) __attribute__((noreturn));
void exit(int status) {
    // In kernel, we can't really exit, so just return
    // This allows Doom errors to return to the main loop
    // Use infinite loop to satisfy noreturn attribute
    while (1) {
        // Loop forever to satisfy noreturn
    }
}

// Stub for abort - infinite loop
void abort(void) {
    // Infinite loop
    while (1) {
        // Infinite loop
    }
}
